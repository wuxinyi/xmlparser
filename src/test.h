 
//----------------------------------------------------------------------
// 此文件由工具自动生成，请勿修改 
// this file is generated by xmltool, so don't change by yourself
//----------------------------------------------------------------------
#include <vector>
#include <string>
#include <map>
#include <utility>
#include "tinyxml2.h"
#include "attribute_parser.h"
#include "lua.hpp"
#include "lauxlib.h"
#include "lualib.h"
using namespace tinyxml2;


namespace xml {
  //XML-->CPP STRUCT
  //this class can load xmlfiles to cpp struct and load them into computer memory
  struct TEST
  {
    bool load()
    {
      XMLDocument doc;
      int ret = 0;
      if((ret = doc.LoadFile("./xml/test.xml")) != XML_SUCCESS) {
        return false;
      }
      XMLElement *ele = NULL;
      ele = doc.FirstChildElement("test");
      if (!ele) return false;
      return this->parse(ele);
    }
    

    struct SKILL
    {
      int id;
      std::string name;
      bool parse(const XMLElement* child)
      {
        if (!child) return false;
        const XMLAttribute* attri = NULL;
        attri = child->FindAttribute("id");
        if (attri)
        {
          this->id= Attribute_Parser<int>()(attri->Value());
        }

        attri = child->FindAttribute("name");
        if (attri)
        {
          this->name= Attribute_Parser<std::string>()(attri->Value());
        }

        return true;
      }
    };
    std::map<int,struct SKILL> skill;
    typedef std::map<int,struct SKILL>::iterator SKILL_It;
    typedef std::map<int,struct SKILL>::const_iterator SKILL_ConstIt;

    bool parse(const XMLElement* child)
    {
      if (!child) return false;
      const XMLAttribute* attri = NULL;
      {
        const XMLElement *ele_begin = NULL;
        const XMLElement *ele_end = NULL;
        ele_begin = child->FirstChildElement("skill");
        ele_end   = child->LastChildElement("skill");
        while(ele_begin)
        {
          if (strcmp(ele_begin->Name(),"skill") != 0) {
            ele_begin = ele_begin->NextSiblingElement();
            continue;
          }
          struct SKILL temp_;
          if (temp_.parse(ele_begin))
          {
            this->skill.insert(std::pair<int, struct SKILL>(temp_.id, temp_));
          }
          if (ele_begin == ele_end) {
            break;
          }
          ele_begin = ele_begin->NextSiblingElement();
        }
      }

      return true;
    }
  };
  static struct TEST test;

  //XML-->LUATABLE
  //this class load xml file into LuaState, we can use config for example "xml.ta.tb.tc" in lua files
  struct LUA_TEST
  {
    void doLoad2luaState(lua_State * L)
    {
      if (NULL == L)
      {
        return;
      }
      this->currL = L;
      this->load();
    }

    bool load()
    {
      XMLDocument doc;
      int ret = 0;
      if((ret = doc.LoadFile("./xml/test.xml")) != XML_SUCCESS) {
        return false;
      }
      bool ret_ = false;
      XMLElement *ele = NULL;
      ele = doc.FirstChildElement("test");
      if (!ele) return false;
      lua_getglobal(this->currL, "xml");
      if (!lua_istable(this->currL, -1))
      {
        lua_pop(this->currL, 1);
        lua_newtable(this->currL);
        lua_setglobal(this->currL, "xml");
        lua_getglobal(this->currL, "xml");
        if (!lua_istable(this->currL,-1))
        {
          lua_pop(this->currL,1);
          return false;
        }
      }
      lua_pushstring(this->currL,"test");
      lua_newtable(this->currL);
      ret_ = this->parse(ele, this->currL);
      lua_settable(this->currL, -3);
      lua_pop(this->currL, 1);
      return ret_;
    }

    bool parse(const XMLElement* child, lua_State * const L)
    {
      if (!child) return false;
      const XMLAttribute* attri = NULL;
      {
        const XMLElement *ele_begin = NULL;
        const XMLElement *ele_end = NULL;
        ele_begin = child->FirstChildElement("skill");
        ele_end   = child->LastChildElement("skill");
        int id = 0;
        while(ele_begin)
        {
          if (strcmp(ele_begin->Name(),"skill") != 0) {
            ele_begin = ele_begin->NextSiblingElement();
            continue;
          }
          if (id == 0) {
            lua_pushstring(L,"skill");
            lua_newtable(L);
          }
          attri = ele_begin->FindAttribute("id");
          if (attri) {
            lua_pushinteger(L, Attribute_Parser<int>()(attri->Value()));
            lua_newtable(L);
            //recursive parse lua table!
            this->skill.parse(ele_begin, L);
            lua_settable(L, -3);
          }
          if (ele_begin == ele_end) {
            lua_settable(L,-3);
            break;
          }
          ele_begin = ele_begin->NextSiblingElement();
          ++ id;
        }
      }

      return true;
    }

    struct LUA_SKILL
    {
      bool parse(const XMLElement* child, lua_State * const L)
      {
        if (!child) return false;
        const XMLAttribute* attri = NULL;
        attri = child->FindAttribute("id");
        if (attri)
        {
          lua_pushstring(L,"id");
          lua_pushinteger(L, Attribute_Parser<int>()(attri->Value()));
          lua_settable(L,-3);
        }

        attri = child->FindAttribute("name");
        if (attri)
        {
          lua_pushstring(L,"name");
          lua_pushstring(L, Attribute_Parser<std::string>()(attri->Value()).c_str());
          lua_settable(L,-3);
        }

        return true;
      }

    };
    struct LUA_SKILL skill;

    lua_State *currL;
  };
  static struct LUA_TEST lua_test;
}
